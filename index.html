<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Valentine Crossword</title>
  <style>
    :root { --cell: 42px; --gap: 2px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#fafafa; color:#111; }
    header { padding: 18px 16px 10px; max-width: 1100px; margin: 0 auto; }
    h1 { margin: 0; font-size: 20px; letter-spacing: .2px; }
    .sub { margin-top: 6px; color:#444; font-size: 13px; line-height: 1.35; }
    .wrap { display: grid; grid-template-columns: 1fr 360px; gap: 18px; max-width: 1100px; margin: 0 auto; padding: 0 16px 18px; }
    @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }

    .card { background:#fff; border: 1px solid #e7e7e7; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.06); }
    .gridCard { padding: 14px; }

    .clueBar {
      display:flex; align-items:center; justify-content: space-between;
      gap: 10px;
      border: 1px solid #eee;
      background: #fcfcfc;
      padding: 10px 12px;
      border-radius: 12px;
      margin-bottom: 10px;
    }
    .clueBar .label { font-size: 12px; color:#666; font-weight: 700; letter-spacing:.3px; text-transform: uppercase; }
    .clueBar .text { font-size: 13px; color:#111; line-height: 1.25; }
    .clueBar .dir { font-size: 12px; color:#444; font-weight: 700; padding: 4px 8px; border: 1px solid #eee; border-radius: 999px; background:#fff; }

    .tools { display:flex; flex-wrap: wrap; gap: 8px; margin: 10px 0 0; }
    button{
      border:1px solid #ddd; background:#fff; padding: 9px 10px; border-radius: 10px;
      cursor:pointer; font-weight:600; font-size: 13px;
    }
    button:hover{ background:#f3f3f3; }
    button.primary{ background:#111; color:#fff; border-color:#111; }
    button.primary:hover{ background:#222; }
    button.danger{ border-color:#f0c3c3; }
    .status { margin-top: 10px; font-size: 13px; color:#333; }

    .grid {
      display: grid;
      gap: var(--gap);
      justify-content: start;
      align-content: start;
      background:#111;
      padding: var(--gap);
      border-radius: 12px;
      width: fit-content;
      max-width: 100%;
      overflow:auto;
    }
    .cell {
      width: var(--cell);
      height: var(--cell);
      background:#fff;
      position: relative;
    }
    .cell.black { background:#111; }
    input.letter {
      width: 100%; height: 100%;
      border: 0; outline: none;
      text-transform: uppercase;
      text-align: center;
      font-size: 20px;
      font-weight: 700;
      background: transparent;
      caret-color: transparent;
    }
    .cell.selected { outline: 3px solid #111; outline-offset: -3px; }
    .cell.highlight { background: #fff7cc; }
    .cell.wrong input { color:#b00020; }
    .cell.correct input { color:#111; }

    .cluesCard { padding: 14px; }
    .tabs { display:flex; gap: 8px; margin-bottom: 10px; }
    .tabBtn { flex: 1; }
    .tabBtn.active { background:#111; border-color:#111; color:#fff; }
    ol { margin: 0; padding-left: 18px; }
    li { margin: 7px 0; font-size: 13px; color:#222; line-height: 1.25; cursor: pointer; }
    li.active { background:#fff7cc; border-radius: 10px; padding: 6px 8px; margin-left: -8px; margin-right: -8px; }
    h2 { font-size: 14px; margin: 0; letter-spacing:.2px; display:none; }

    .modalBackdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,.55);
      display:none; align-items: center; justify-content: center; padding: 18px;
    }
    .modal { max-width: 520px; width: 100%; padding: 18px; border-radius: 16px; background:#fff; border:1px solid #eee; }
    .modal h3 { margin: 0 0 6px; font-size: 18px; }
    .modal p { margin: 0 0 12px; color:#333; line-height: 1.35; }
    .modal .row { display:flex; gap: 10px; flex-wrap: wrap; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #e6e6e6; color:#444; background:#fafafa; }
    .footerNote { font-size: 12px; color:#666; margin-top: 10px; }
  </style>
</head>
<body>
  <header>
    <h1>Mini Valentine Crossword</h1>
    <div class="sub">
      Solve the crossword. When you finish‚Ä¶ there‚Äôs a question waiting. üíå
      <div class="footerNote">Tip: Click a square, type letters. Press <b>Tab</b> to switch Across/Down.</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card gridCard">
      <div class="clueBar">
        <div>
          <div class="label">Current clue</div>
          <div id="currentClue" class="text">Click a square to begin.</div>
        </div>
        <div id="currentDir" class="dir">Across</div>
      </div>

      <div id="grid" class="grid" aria-label="crossword grid"></div>

      <div class="tools">
        <button id="hintBtn" class="primary">Hint (reveal 1 letter)</button>
        <button id="checkBtn">Check</button>
        <button id="clearBtn" class="danger">Clear</button>
      </div>
      <div id="status" class="status"></div>
    </section>

    <aside class="card cluesCard">
      <div class="tabs">
        <button id="acrossTab" class="tabBtn active">Across</button>
        <button id="downTab" class="tabBtn">Down</button>
      </div>
      <ol id="clueList"></ol>
    </aside>
  </main>

  <div id="modalBackdrop" class="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="pill">Solved ‚úÖ</div>
      <h3 id="modalTitle">Will you be my Valentine?</h3>
      <p id="modalText">I made this from our clues, our memories, and (a little) code. üíó</p>
      <div class="row">
        <button id="yesBtn" class="primary">Yes üíò</button>
        <button id="closeBtn">Close</button>
      </div>
    </div>
  </div>

<script>
/**
 * FIXED GRID (no regeneration)
 * # = black square
 * Letters = solution
 */
const FIXED_GRID = [
  "#################",
  "#####N###########",
  "#####B###########",
  "##K##H##P########",
  "##H#####A########",
  "#LAPELPIN#ZAM####",
  "##L##O##D########",
  "##J##C#NONE######",
  "#LIZ#H##R##P#####",
  "#####N#MATCHA####",
  "#CLYDE#####O#####",
  "#####S#F##STORR##",
  "##LETSGO###O#####",
  "#######Y###SHEIN#",
  "######VEIL####T##",
  "#######R######T##",
  "############IMAD#",
  "#################",
];

// Your clues
const CLUES = {
  "KHALJI": "He is big, he is powerful, sometimes causes delays and for some reason intimidates your brother.",
  "LETSGO": "Not quite on a knee, but an invite to forever.",
  "PANDORA": "A gift from my travel, never adorned.",
  "LAPELPIN": "Safi stands with UAE.",
  "VEIL": "A part of your shaadi garment, I never got to see",
  "LOCHNESS": "Drenched pants, cold fingers and 3 rainbows later, never found.",
  "LIZ": "Cat lady gardner of Oxfordshire",
  "CLYDE": "Moody's furry scottish brother",
  "MATCHA": "A green slap to the face I only tolerate during the day",
  "ZAM": "Your local comfort food joint",
  "NONE": "My favourite cheesecake topping",
  "SHEIN": "The order never placed",
  "ITTA": "How much do you love me?",
  "IMAD": "The legend. The greatest. The hottest. The man that makes all men want to be him.",
  "NBH": "The \"sweet\" man of Malaz",
  "STORR": "The old man that made you cry",
  "PHOTOS": "We will get to it someday...",
  "FOYER": "Our next home improvement project (Inshallah)",
};

let STATE = null;

function setStatus(msg){ document.getElementById("status").textContent = msg; }
function getCellEl(r,c){ return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

function buildFromFixed(){
  const grid = FIXED_GRID.map(row => row.split("").map(ch => ch === "#" ? null : ch));
  const rows = grid.length;
  const cols = grid[0].length;

  const acrossList = [];
  const downList = [];

  const isBlack = (r,c)=> grid[r][c] === null;

  // Across
  for(let r=0;r<rows;r++){
    let c=0;
    while(c<cols){
      if(isBlack(r,c)){ c++; continue; }
      const start = c;
      while(c<cols && !isBlack(r,c)) c++;
      const word = grid[r].slice(start,c).join("");
      if(word.length>=3){
        acrossList.push({ answer: word, clue: CLUES[word] || "(missing clue)", r, c:start, dir:"across" });
      }
    }
  }

  // Down
  for(let c=0;c<cols;c++){
    let r=0;
    while(r<rows){
      if(isBlack(r,c)){ r++; continue; }
      const start = r;
      while(r<rows && !isBlack(r,c)) r++;
      let word = "";
      for(let rr=start; rr<r; rr++) word += grid[rr][c];
      if(word.length>=3){
        downList.push({ answer: word, clue: CLUES[word] || "(missing clue)", r:start, c, dir:"down" });
      }
    }
  }

  STATE = {
    solution: grid,
    rows, cols,
    acrossList,
    downList,
    view: "across", // which tab is showing
    selected: { r:0, c:0, dir:"across" },
    activeClueKey: null,
  };

  renderGrid();
  renderClueList();
  setStatus("Ready. üíå Click a square to begin.");

  // select first non-black
  outer: for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(STATE.solution[r][c]!==null){
        selectCell(r,c,"across", true);
        break outer;
      }
    }
  }
}

function renderGrid(){
  const { rows, cols, solution } = STATE;
  const gridEl = document.getElementById("grid");
  gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
  gridEl.innerHTML = "";

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cellEl = document.createElement("div");
      cellEl.className = "cell" + (solution[r][c]===null ? " black" : "");
      cellEl.dataset.r = r;
      cellEl.dataset.c = c;

      if(solution[r][c]!==null){
        const inp = document.createElement("input");
        inp.className = "letter";
        inp.maxLength = 1;
        inp.autocomplete = "off";
        inp.spellcheck = false;

        inp.addEventListener("focus", ()=> selectCell(r,c,STATE.selected.dir, true));
        inp.addEventListener("keydown", (e)=> onKey(e, r, c));
        inp.addEventListener("input", ()=> {
          inp.value = (inp.value || "").toUpperCase().replace(/[^A-Z]/g,"");
          moveNext();
          checkWin(false);
        });

        cellEl.appendChild(inp);

        cellEl.addEventListener("click", ()=>{
          // click same cell toggles direction
          if(STATE.selected.r===r && STATE.selected.c===c){
            const newDir = STATE.selected.dir === "across" ? "down" : "across";
            selectCell(r,c,newDir,true);
          } else {
            selectCell(r,c,STATE.selected.dir,true);
          }
        });
      }

      gridEl.appendChild(cellEl);
    }
  }

  highlightCurrentWord();
}

function renderClueList(){
  const listEl = document.getElementById("clueList");
  listEl.innerHTML = "";

  const data = STATE.view === "across" ? STATE.acrossList : STATE.downList;

  data.forEach((item, idx) => {
    const li = document.createElement("li");
    li.textContent = item.clue; // NO numbers, NO lengths
    li.dataset.key = `${item.dir}:${item.r}:${item.c}:${item.answer}`;
    li.addEventListener("click", ()=> selectCell(item.r, item.c, item.dir, true));
    listEl.appendChild(li);
  });

  // tabs styling
  document.getElementById("acrossTab").classList.toggle("active", STATE.view==="across");
  document.getElementById("downTab").classList.toggle("active", STATE.view==="down");
  updateClueBar();
  highlightActiveClueInList();
}

function updateClueBar(){
  const clueEl = document.getElementById("currentClue");
  const dirEl  = document.getElementById("currentDir");

  const item = findSelectedClueItem();
  dirEl.textContent = (STATE.selected.dir === "across") ? "Across" : "Down";

  if(item){
    clueEl.textContent = item.clue;
  } else {
    clueEl.textContent = "Click a square to begin.";
  }
}

function findSelectedClueItem(){
  const { r, c, dir } = STATE.selected;
  const list = dir === "across" ? STATE.acrossList : STATE.downList;

  // find the word start for selected cell
  const start = findWordStart(r,c,dir);
  const match = list.find(x => x.r === start.r && x.c === start.c && x.dir === dir);
  return match || null;
}

function highlightActiveClueInList(){
  const item = findSelectedClueItem();
  document.querySelectorAll("#clueList li").forEach(li => li.classList.remove("active"));
  if(!item) return;

  const key = `${item.dir}:${item.r}:${item.c}:${item.answer}`;
  const li = document.querySelector(`#clueList li[data-key="${CSS.escape(key)}"]`);
  if(li) li.classList.add("active");
}

function selectCell(r,c,dir, focusInput=false){
  STATE.selected = { r,c,dir };

  document.querySelectorAll(".cell.selected").forEach(el=> el.classList.remove("selected"));
  const el = getCellEl(r,c);
  if(el) el.classList.add("selected");
  if(focusInput && el){
    const inp = el.querySelector("input.letter");
    if(inp) inp.focus({preventScroll:true});
  }

  // auto-switch tab to match direction
  STATE.view = dir;
  renderClueList(); // updates clue bar + highlight
  highlightCurrentWord();
}

function findWordStart(r,c,dir){
  const { solution } = STATE;
  let rr=r, cc=c;
  if(solution[rr][cc]===null) return {r,c};

  if(dir==="across"){
    while(cc>0 && solution[rr][cc-1]!==null) cc--;
    return {r:rr,c:cc};
  } else {
    while(rr>0 && solution[rr-1][cc]!==null) rr--;
    return {r:rr,c:cc};
  }
}

function highlightCurrentWord(){
  document.querySelectorAll(".cell.highlight").forEach(el=> el.classList.remove("highlight"));
  const { r, c, dir } = STATE.selected;
  const { solution, rows, cols } = STATE;
  if(solution[r][c]===null) return;

  const start = findWordStart(r,c,dir);
  let rr=start.r, cc=start.c;

  if(dir==="across"){
    while(cc<cols && solution[rr][cc]!==null){
      getCellEl(rr,cc)?.classList.add("highlight");
      cc++;
    }
  } else {
    while(rr<rows && solution[rr][cc]!==null){
      getCellEl(rr,cc)?.classList.add("highlight");
      rr++;
    }
  }
}

function onKey(e, r, c){
  const { solution } = STATE;
  if(solution[r][c]===null) return;

  const key = e.key;

  // TAB = switch across/down
  if(key === "Tab"){
    e.preventDefault();
    const newDir = STATE.selected.dir === "across" ? "down" : "across";
    selectCell(r,c,newDir,true);
    return;
  }

  if(key==="ArrowLeft"){ e.preventDefault(); move(r,c,"left"); }
  else if(key==="ArrowRight"){ e.preventDefault(); move(r,c,"right"); }
  else if(key==="ArrowUp"){ e.preventDefault(); move(r,c,"up"); }
  else if(key==="ArrowDown"){ e.preventDefault(); move(r,c,"down"); }
  else if(key==="Backspace"){
    const inp = getCellEl(r,c).querySelector("input.letter");
    if(inp && inp.value){
      inp.value = "";
    } else {
      e.preventDefault();
      movePrev();
    }
  }
}

function move(r,c,dir){
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;
  const step = (d)=>{
    if(d==="left") cc--;
    if(d==="right") cc++;
    if(d==="up") rr--;
    if(d==="down") rr++;
  };
  step(dir);
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      const newDir = (dir==="left"||dir==="right") ? "across" : "down";
      selectCell(rr,cc,newDir,true);
      return;
    }
    step(dir);
  }
}

function moveNext(){
  const { r, c, dir } = STATE.selected;
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;
  if(dir==="across") cc++;
  else rr++;
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      selectCell(rr,cc,dir,true);
      return;
    }
    if(dir==="across") cc++;
    else rr++;
  }
}

function movePrev(){
  const { r, c, dir } = STATE.selected;
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;
  if(dir==="across") cc--;
  else rr--;
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      selectCell(rr,cc,dir,true);
      return;
    }
    if(dir==="across") cc--;
    else rr--;
  }
}

function check(markWrong=true){
  const { rows, cols, solution } = STATE;
  let wrong = 0, filled = 0, total = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(solution[r][c]===null) continue;
      total++;
      const el = getCellEl(r,c);
      const inp = el.querySelector("input.letter");
      const val = (inp.value || "").toUpperCase();
      el.classList.remove("wrong","correct");
      if(val) filled++;
      if(val && val !== solution[r][c]){
        wrong++;
        if(markWrong) el.classList.add("wrong");
      } else if(val && val === solution[r][c]){
        el.classList.add("correct");
      }
    }
  }

  if(wrong===0 && filled===total){
    setStatus("Perfect! ‚úÖ");
    showModal();
  } else {
    setStatus(`Filled ${filled}/${total}. Wrong squares: ${wrong}.`);
  }
}

function clearAll(){
  document.querySelectorAll("input.letter").forEach(i=> i.value="");
  document.querySelectorAll(".cell.wrong,.cell.correct").forEach(el=> el.classList.remove("wrong","correct"));
  setStatus("Cleared.");
}

function hint(){
  const { rows, cols, solution } = STATE;
  const candidates = [];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(solution[r][c]===null) continue;
      const el = getCellEl(r,c);
      const inp = el.querySelector("input.letter");
      const val = (inp.value || "").toUpperCase();
      if(val !== solution[r][c]) candidates.push([r,c]);
    }
  }
  if(candidates.length===0){
    setStatus("No hint needed ‚Äî everything is correct so far.");
    return;
  }
  const [r,c] = candidates[Math.floor(Math.random()*candidates.length)];
  const el = getCellEl(r,c);
  const inp = el.querySelector("input.letter");
  inp.value = solution[r][c];
  el.classList.remove("wrong");
  el.classList.add("correct");
  selectCell(r,c,STATE.selected.dir,true);
  checkWin(false);
  setStatus("Hint used: revealed one letter ‚ú®");
}

function checkWin(show=true){
  const { rows, cols, solution } = STATE;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(solution[r][c]===null) continue;
      const inp = getCellEl(r,c).querySelector("input.letter");
      if(((inp.value||"").toUpperCase()) !== solution[r][c]) return false;
    }
  }
  if(show) showModal();
  return true;
}

// Modal
function showModal(){ document.getElementById("modalBackdrop").style.display = "flex"; }
function closeModal(){ document.getElementById("modalBackdrop").style.display = "none"; }

document.getElementById("hintBtn").addEventListener("click", hint);
document.getElementById("checkBtn").addEventListener("click", ()=>check(true));
document.getElementById("clearBtn").addEventListener("click", clearAll);

document.getElementById("acrossTab").addEventListener("click", ()=>{
  STATE.view = "across";
  STATE.selected.dir = "across";
  renderClueList();
});
document.getElementById("downTab").addEventListener("click", ()=>{
  STATE.view = "down";
  STATE.selected.dir = "down";
  renderClueList();
});

document.getElementById("closeBtn").addEventListener("click", closeModal);
document.getElementById("modalBackdrop").addEventListener("click", (e)=>{ if(e.target.id==="modalBackdrop") closeModal(); });

document.getElementById("yesBtn").addEventListener("click", ()=>{
  document.getElementById("modalTitle").textContent = "YAY üíò";
  document.getElementById("modalText").textContent = "Happy Valentine‚Äôs ‚Äî I choose you, always. ü•π‚ù§Ô∏è";
});

buildFromFixed();
</script>
</body>
</html>
