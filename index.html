<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Valentine Crossword</title>
  <style>
    :root { --cell: 42px; --gap: 2px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#fafafa; color:#111; }
    header { padding: 18px 16px 10px; max-width: 1100px; margin: 0 auto; }
    h1 { margin: 0; font-size: 20px; letter-spacing: .2px; }
    .sub { margin-top: 6px; color:#444; font-size: 13px; line-height: 1.35; }
    .wrap { display: grid; grid-template-columns: 1fr 360px; gap: 18px; max-width: 1100px; margin: 0 auto; padding: 0 16px 18px; }
    @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }

    .card { background:#fff; border: 1px solid #e7e7e7; border-radius: 14px; box-shadow: 0 6px 18px rgba(0,0,0,.06); }
    .gridCard { padding: 14px; }
    .tools { display:flex; flex-wrap: wrap; gap: 8px; margin: 10px 0 0; }
    button{
      border:1px solid #ddd; background:#fff; padding: 9px 10px; border-radius: 10px;
      cursor:pointer; font-weight:600; font-size: 13px;
    }
    button:hover{ background:#f3f3f3; }
    button.primary{ background:#111; color:#fff; border-color:#111; }
    button.primary:hover{ background:#222; }
    button.danger{ border-color:#f0c3c3; }
    .status { margin-top: 10px; font-size: 13px; color:#333; }

    .grid {
      display: grid;
      gap: var(--gap);
      justify-content: start;
      align-content: start;
      background:#111;
      padding: var(--gap);
      border-radius: 12px;
      width: fit-content;
      max-width: 100%;
      overflow:auto;
    }
    .cell {
      width: var(--cell);
      height: var(--cell);
      background:#fff;
      position: relative;
    }
    .cell.black { background:#111; }
    .num {
      position:absolute; top: 3px; left: 4px;
      font-size: 10px; color:#111; opacity:.7; font-weight:700;
      pointer-events:none;
    }
    input.letter {
      width: 100%; height: 100%;
      border: 0; outline: none;
      text-transform: uppercase;
      text-align: center;
      font-size: 20px;
      font-weight: 700;
      background: transparent;
      caret-color: transparent;
    }
    .cell.selected { outline: 3px solid #111; outline-offset: -3px; }
    .cell.highlight { background: #fff7cc; }
    .cell.wrong input { color:#b00020; }
    .cell.correct input { color:#111; }

    .cluesCard { padding: 14px; }
    .clueCols { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 980px){ .clueCols{ grid-template-columns: 1fr; } }
    h2 { font-size: 14px; margin: 0 0 8px; letter-spacing:.2px; }

    /* No bullets */
    ul { margin: 0; padding: 0; list-style: none; }

    li {
      margin: 6px 0;
      font-size: 13px;
      color:#222;
      line-height: 1.25;
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
    }
    li:hover { background:#f5f5f5; }
    li.active { background: #fff7cc; }
    li span.answerLen { color:#777; font-weight:600; margin-left: 6px; font-size: 12px; }

    .modalBackdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,.55);
      display:none; align-items: center; justify-content: center; padding: 18px;
    }
    .modal { max-width: 520px; width: 100%; padding: 18px; border-radius: 16px; background:#fff; border:1px solid #eee; }
    .modal h3 { margin: 0 0 6px; font-size: 18px; }
    .modal p { margin: 0 0 12px; color:#333; line-height: 1.35; }
    .modal .row { display:flex; gap: 10px; flex-wrap: wrap; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #e6e6e6; color:#444; background:#fafafa; }
    .footerNote { font-size: 12px; color:#666; margin-top: 10px; }
  </style>
</head>
<body>
  <header>
    <h1>Mini Valentine Crossword</h1>
    <div class="sub">
      Solve the crossword. When you finish‚Ä¶ there‚Äôs a question waiting. üíå
      <div class="footerNote">Tip: click a square, type letters. Use arrows / backspace. Click again to switch Across/Down.</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card gridCard">
      <div id="grid" class="grid" aria-label="crossword grid"></div>
      <div class="tools">
        <button id="checkBtn" class="primary">Check</button>
        <button id="clearBtn" class="danger">Clear</button>
      </div>
      <div id="status" class="status"></div>
    </section>

    <aside class="card cluesCard">
      <div class="clueCols">
        <div>
          <h2>Across</h2>
          <ul id="across"></ul>
        </div>
        <div>
          <h2>Down</h2>
          <ul id="down"></ul>
        </div>
      </div>
    </aside>
  </main>

  <div id="modalBackdrop" class="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="pill">Solved ‚úÖ</div>
      <h3 id="modalTitle">Will you be my Valentine?</h3>
      <p id="modalText">I made this from our clues, our memories, and (a little) code. üíó</p>
      <div class="row">
        <button id="yesBtn" class="primary">Yes üíò</button>
        <button id="closeBtn">Close</button>
      </div>
    </div>
  </div>

<script>
/**
 * FIXED GRID (uses ALL 20 words, and is fully connected)
 * # = black square
 * Letters = solution
 */
const FIXED_GRID = [
  "####################",
  "###P#######S########",
  "#Z#H##K####L#J######",
  "#A#O##H#NONE#A######",
  "#MATCHA####E#A######",
  "###O##LAPELPIN######",
  "###S##J#A#O###V#LIZ#",
  "######I#N#CLYDE##M##",
  "#####S##D#H###ITTA##",
  "###LETSGO#NBH#L##D##",
  "#####O##R#E#########",
  "#FOYER##A#SHEIN#####",
  "#####R####S#########",
  "####################",
];

const CLUES = {
  KHALJI: "He is big, he is powerful, sometimes causes delays and for some reason intimidates your brother.",
  LETSGO: "Not quite on a knee, but my invite to forever.",
  PANDORA: "A gift from my travel, never adorned.",
  LAPELPIN: "Safi stands with UAE.",
  VEIL: "A part of your shaadi garment, I never got to see.",
  LOCHNESS: "Drenched pants, cold fingers and 3 rainbows later, never found.",
  LIZ: "Cat lady gardner of Oxfordshire.",
  CLYDE: "Moody's furry scottish cousin.",
  MATCHA: "A green slap to the face I only tolerate during the day.",
  ZAM: "Your local comfort food joint. Abbr.",
  NONE: "My favourite cheesecake topping.",
  SHEIN: "The order never placed.",
  ITTA: "How much do you love me?",
  IMAD: "The legend. The greatest. The hottest. The man that makes all men want to be him.",
  NBH: 'The "sweet" man of Malaz. Abbr.',
  STORR: "The old man that made you cry.",
  PHOTOS: "We will get to it someday...",
  FOYER: "Our next home improvement project (Inshallah).",
  JAAN: "Nabihah Abdul Hafeez, to me.",
  SLEEP: "I need much more of it my life.",
};

let STATE = null;

function setStatus(msg){ document.getElementById("status").textContent = msg; }
function getCellEl(r,c){ return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

function buildFromFixed(){
  const grid = FIXED_GRID.map(row => row.split("").map(ch => ch === "#" ? null : ch));
  const rows = grid.length;
  const cols = grid[0].length;

  const isBlack = (r,c)=> grid[r][c] === null;

  // numbering like NYT (starts of across/down)
  const numbers = Array.from({length:rows}, ()=> Array.from({length:cols}, ()=> 0));
  let num = 1;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(isBlack(r,c)) continue;
      const startsAcross = (c===0 || isBlack(r,c-1)) && (c+1<cols && !isBlack(r,c+1));
      const startsDown   = (r===0 || isBlack(r-1,c)) && (r+1<rows && !isBlack(r+1,c));
      if(startsAcross || startsDown) numbers[r][c] = num++;
    }
  }

  // extract across/down entries from the fixed grid
  const acrossList = [];
  const downList = [];

  // Across
  for(let r=0;r<rows;r++){
    let c=0;
    while(c<cols){
      if(isBlack(r,c)){ c++; continue; }
      const start = c;
      while(c<cols && !isBlack(r,c)) c++;
      const word = grid[r].slice(start,c).join("");
      if(word.length>=3 && numbers[r][start]>0){
        acrossList.push({ number: numbers[r][start], answer: word, clue: CLUES[word] || "(missing clue)", r, c:start, dir:"across" });
      }
    }
  }

  // Down
  for(let c=0;c<cols;c++){
    let r=0;
    while(r<rows){
      if(isBlack(r,c)){ r++; continue; }
      const start = r;
      while(r<rows && !isBlack(r,c)) r++;
      let word = "";
      for(let rr=start; rr<r; rr++) word += grid[rr][c];
      if(word.length>=3 && numbers[start][c]>0){
        downList.push({ number: numbers[start][c], answer: word, clue: CLUES[word] || "(missing clue)", r:start, c, dir:"down" });
      }
    }
  }

  STATE = {
    solution: grid,
    numbers,
    rows, cols,
    acrossList: acrossList.sort((a,b)=>a.number-b.number),
    downList: downList.sort((a,b)=>a.number-b.number),
    selected: { r:0, c:0, dir:"across" }
  };

  renderGrid();
  renderClues();
  setStatus("Ready. üíå");

  // select first non-black
  outer: for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(STATE.solution[r][c]!==null){
        selectCell(r,c,"across", true);
        break outer;
      }
    }
  }
}

function renderGrid(){
  const { rows, cols, solution, numbers } = STATE;
  const gridEl = document.getElementById("grid");
  gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
  gridEl.innerHTML = "";

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cellEl = document.createElement("div");
      cellEl.className = "cell" + (solution[r][c]===null ? " black" : "");
      cellEl.dataset.r = r;
      cellEl.dataset.c = c;

      if(solution[r][c]!==null){
        if(numbers[r][c]){
          const n = document.createElement("div");
          n.className = "num";
          n.textContent = numbers[r][c];
          cellEl.appendChild(n);
        }

        const inp = document.createElement("input");
        inp.className = "letter";
        inp.maxLength = 1;
        inp.autocomplete = "off";
        inp.spellcheck = false;
        inp.inputMode = "text";

        inp.addEventListener("focus", ()=> selectCell(r,c,STATE.selected.dir, true));
        inp.addEventListener("keydown", (e)=> onKey(e, r, c));
        inp.addEventListener("input", ()=> {
          inp.value = (inp.value || "").toUpperCase().replace(/[^A-Z]/g,"");
          moveNext();
          checkWin(false);
        });

        cellEl.appendChild(inp);

        cellEl.addEventListener("click", ()=>{
          if(STATE.selected.r===r && STATE.selected.c===c){
            const newDir = STATE.selected.dir === "across" ? "down" : "across";
            selectCell(r,c,newDir,true);
          } else {
            selectCell(r,c,STATE.selected.dir,true);
          }
        });
      }

      gridEl.appendChild(cellEl);
    }
  }

  highlightCurrentWord();
}

function renderClues(){
  const acrossEl = document.getElementById("across");
  const downEl = document.getElementById("down");
  acrossEl.innerHTML = "";
  downEl.innerHTML = "";

  for(const item of STATE.acrossList){
    const li = document.createElement("li");
    li.dataset.dir = "across";
    li.dataset.number = String(item.number);
    li.innerHTML = `<strong>${item.number}.</strong> ${escapeHtml(item.clue)} <span class="answerLen">(${item.answer.length})</span>`;
    li.addEventListener("click", ()=> selectCell(item.r, item.c, "across", true));
    acrossEl.appendChild(li);
  }

  for(const item of STATE.downList){
    const li = document.createElement("li");
    li.dataset.dir = "down";
    li.dataset.number = String(item.number);
    li.innerHTML = `<strong>${item.number}.</strong> ${escapeHtml(item.clue)} <span class="answerLen">(${item.answer.length})</span>`;
    li.addEventListener("click", ()=> selectCell(item.r, item.c, "down", true));
    downEl.appendChild(li);
  }
}

function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

function getWordStart(r,c,dir){
  const { solution } = STATE;
  if(solution[r][c]===null) return {r,c};
  if(dir==="across"){
    while(c>0 && solution[r][c-1]!==null) c--;
    return {r,c};
  } else {
    while(r>0 && solution[r-1][c]!==null) r--;
    return {r,c};
  }
}

function updateActiveClue(){
  const { r, c, dir } = STATE.selected;
  const start = getWordStart(r,c,dir);
  const num = STATE.numbers[start.r][start.c];

  document.querySelectorAll("li.active").forEach(li => li.classList.remove("active"));

  const listId = dir === "across" ? "across" : "down";
  const listEl = document.getElementById(listId);
  const target = listEl.querySelector(`li[data-dir="${dir}"][data-number="${num}"]`);
  if(target){
    target.classList.add("active");
    target.scrollIntoView({ block: "nearest" });
  }
}

function selectCell(r,c,dir, focusInput=false){
  STATE.selected = { r,c,dir };

  document.querySelectorAll(".cell.selected").forEach(el=> el.classList.remove("selected"));
  const el = getCellEl(r,c);
  if(el) el.classList.add("selected");

  if(focusInput && el){
    const inp = el.querySelector("input.letter");
    if(inp) inp.focus({preventScroll:true});
  }

  highlightCurrentWord();
  updateActiveClue();
}

function highlightCurrentWord(){
  document.querySelectorAll(".cell.highlight").forEach(el=> el.classList.remove("highlight"));
  const { r, c, dir } = STATE.selected;
  const { solution, rows, cols } = STATE;
  if(solution[r][c]===null) return;

  let sr=r, sc=c;

  if(dir==="across"){
    while(sc>0 && solution[sr][sc-1]!==null) sc--;
    let cc=sc;
    while(cc<cols && solution[sr][cc]!==null){
      getCellEl(sr,cc)?.classList.add("highlight");
      cc++;
    }
  } else {
    while(sr>0 && solution[sr-1][sc]!==null) sr--;
    let rr=sr;
    while(rr<rows && solution[rr][sc]!==null){
      getCellEl(rr,sc)?.classList.add("highlight");
      rr++;
    }
  }
}

function onKey(e, r, c){
  const { solution } = STATE;
  if(solution[r][c]===null) return;

  const key = e.key;

  if(key==="ArrowLeft"){ e.preventDefault(); move(r,c,"left"); }
  else if(key==="ArrowRight"){ e.preventDefault(); move(r,c,"right"); }
  else if(key==="ArrowUp"){ e.preventDefault(); move(r,c,"up"); }
  else if(key==="ArrowDown"){ e.preventDefault(); move(r,c,"down"); }
  else if(key==="Backspace"){
    const inp = getCellEl(r,c).querySelector("input.letter");
    if(inp && inp.value){
      inp.value = "";
    } else {
      e.preventDefault();
      movePrev();
    }
    updateActiveClue();
  } else if(key==="Enter"){
    e.preventDefault();
    const newDir = STATE.selected.dir === "across" ? "down" : "across";
    selectCell(r,c,newDir,true);
  }
}

function move(r,c,dir){
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;

  const step = (d)=>{
    if(d==="left") cc--;
    if(d==="right") cc++;
    if(d==="up") rr--;
    if(d==="down") rr++;
  };

  step(dir);
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      const newDir = (dir==="left"||dir==="right") ? "across" : "down";
      selectCell(rr,cc,newDir,true);
      return;
    }
    step(dir);
  }
}

function moveNext(){
  const { r, c, dir } = STATE.selected;
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;
  if(dir==="across") cc++;
  else rr++;
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      selectCell(rr,cc,dir,true);
      return;
    }
    if(dir==="across") cc++;
    else rr++;
  }
}

function movePrev(){
  const { r, c, dir } = STATE.selected;
  const { rows, cols, solution } = STATE;
  let rr=r, cc=c;
  if(dir==="across") cc--;
  else rr--;
  while(rr>=0 && cc>=0 && rr<rows && cc<cols){
    if(solution[rr][cc]!==null){
      selectCell(rr,cc,dir,true);
      return;
    }
    if(dir==="across") cc--;
    else rr--;
  }
}

function check(markWrong=true){
  const { rows, cols, solution } = STATE;
  let wrong = 0, filled = 0, total = 0;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(solution[r][c]===null) continue;
      total++;
      const el = getCellEl(r,c);
      const inp = el.querySelector("input.letter");
      const val = (inp.value || "").toUpperCase();
      el.classList.remove("wrong","correct");
      if(val) filled++;
      if(val && val !== solution[r][c]){
        wrong++;
        if(markWrong) el.classList.add("wrong");
      } else if(val && val === solution[r][c]){
        el.classList.add("correct");
      }
    }
  }

  if(wrong===0 && filled===total){
    setStatus("Perfect! ‚úÖ");
    showModal();
  } else {
    setStatus(`Filled ${filled}/${total}. Wrong squares: ${wrong}.`);
  }
}

function clearAll(){
  document.querySelectorAll("input.letter").forEach(i=> i.value="");
  document.querySelectorAll(".cell.wrong,.cell.correct").forEach(el=> el.classList.remove("wrong","correct"));
  setStatus("Cleared.");
}

function checkWin(show=true){
  const { rows, cols, solution } = STATE;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(solution[r][c]===null) continue;
      const inp = getCellEl(r,c).querySelector("input.letter");
      if(((inp.value||"").toUpperCase()) !== solution[r][c]) return false;
    }
  }
  if(show) showModal();
  return true;
}

// Modal
function showModal(){ document.getElementById("modalBackdrop").style.display = "flex"; }
function closeModal(){ document.getElementById("modalBackdrop").style.display = "none"; }

document.getElementById("checkBtn").addEventListener("click", ()=>check(true));
document.getElementById("clearBtn").addEventListener("click", clearAll);

document.getElementById("closeBtn").addEventListener("click", closeModal);
document.getElementById("modalBackdrop").addEventListener("click", (e)=>{ if(e.target.id==="modalBackdrop") closeModal(); });

document.getElementById("yesBtn").addEventListener("click", ()=>{
  document.getElementById("modalTitle").textContent = "YAY üíò";
  document.getElementById("modalText").textContent = "Happy Valentine‚Äôs ‚Äî I choose you, always. ü•π‚ù§Ô∏è";
});

buildFromFixed();
</script>
</body>
</html>
